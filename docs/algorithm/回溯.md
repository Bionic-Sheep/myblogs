如何理解回溯？

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

回溯搜索的遍历过程

![回溯算法理论基础](https://cdn.jsdelivr.net/gh/Bionic-Sheep/typora/images/20210130173631174.png)

可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

模板

```java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```







## LeetCode

### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```java
//回溯，也是递归遍历
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> ans = new ArrayList<>();
        if(root == null) return ans;
        backtracking(root, "", ans);
        return ans;
    }

    public void backtracking(TreeNode root, String str, List<String> ans){
         //说明该节点为叶子节点,满足终止条件
        if(root.left == null && root.right == null){
            str += root.val;
            ans.add(str);
            return;
        }

        if(root.left != null){
            backtracking(root.left, str + root.val + "->", ans); //回溯
        }

        if(root.right != null){
            backtracking(root.right, str + root.val + "->", ans);
        }
    }
}
```



### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```java
class Solution {
    //最底层、最左边：叶子深度最大的就是最低成，最左边采用前序遍历先向搜索左边，那么就是最底层最左边
    int max = -1; //记录深度
    int val = 0; // 记录值
    public int findBottomLeftValue(TreeNode root) {
        dfs(root, 0);
        return val;
    }
    //遍历整棵树，所以递归函数不用返回值
    public void dfs(TreeNode root, int deep){
        //找到叶子节点,因为是前序遍历，左边的节点一定比右边的节点先搜索到，因为根左右
        if(root.left == null && root.right == null){
            if(max < deep){
                max = deep;
                val = root.val;
                return ;
            }
        }
        //回溯
        if(root.left != null){
            deep++;
            dfs(root.left, deep);
            deep--; //回溯
        }
        if(root.right != null){
            deep++;
            dfs(root.right, deep);
            deep--; //回溯
        }
    }
}
```



### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

```java

class Solution {
    boolean flag = false;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        backtrack(root, targetSum, root.val);
        return flag;
    }

    public void backtrack(TreeNode root, int targetSum, int sum){
        if(root.left == null && root.right == null && targetSum == sum){
            flag = true;
        }
        if(root.left!= null)
        backtrack(root.left, targetSum, sum + root.left.val);
        if(root.right != null)
        backtrack(root.right, targetSum, sum + root.right.val);
    }
}
```



### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> list = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtrack(k, n, 1, 0);
        return ans;
    }

    public void backtrack(int k, int n, int index, int sum){
        if(sum > n) return ;
        if(sum == n && list.size() == k){
            ans.add(new ArrayList(list));
            return ;
        }

        for(int i = index; i <= 9; ++i){    
            list.add(i);
            backtrack(k, n, i+1, sum+i);
            list.remove(list.size()-1);
        }
    }
}
```



### 