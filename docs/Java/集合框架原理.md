# 集合的面经

# 说说List、Set、Map三者区别？

1. List、Set是实现了Collection接口的子接口；而Map是另一个集合接口。
2. 元素重复性 → 元素有序性 → 元素是否为空值（**详细**）
    1. **List**，允许重复元素，**Set**，不允许重复元素，**Map**，以键值对存储元素，不允许重复键，但允许不同的键存储重复的值
    2. **List**，每个元素有对应的索引，这些索引按照元素的添加顺序设置，**Set**，中的元素是无序，不保证插入顺序，**Map**，中的元素也是无序存储
        
        1. Set有个LinkedHashSet例外，按照元素的插入顺序进行排序，Map中有个TreeMap例外，可以根据键队进行升序排序。
    3. **List**，允许任意数量的空置，**Set**，只能有一个空置，**Map**，只能有一个空键，任意数量的空值
    4. 总结（**略讲**）
       
        **List**，有序，可重复，允许任意空值。
        
        **Set**，无序，不可重复，允许一个空值。
        
        **Map**，无序，键不可重复，值可重复，键允许一个空值，值允许任意空值
        



## ArrayList、LinkedList和Vector的区别？

1. 底层数据数据结构实现 → 插入删除时的表现 → 是否支持快速随机访问 → 内存空间和线程安全（补充）
    1. **ArrayList** 和 **Vector**都是基于动态数组实现，**LinkedList**是基于双向链表实现。
    2. **ArrayList**，随机访问，插入删除不友好，**Vector**，同理，**LinkeList**，不支持随机访问，插入删除友好
    3. **ArrayList**，list的列表结尾会预留一定的内存空间用于扩容，**LinkedList**的每个元素都预留空间用于存放前继后继指针和数据。
        
        - ArrayList和LinkedList谁更占内存？
          
            一般情况是LinkedList更占内存，因为节点需要维护两个前后地址的节点，但遇见数据量刚好超过ArrayList默认的临时值，会进行扩容，因为扩容会浪费原来数组一半的容量。
        
    4. **ArrayList**和**LinkedLis**t都是不同步，线程不安全，性能高；**Vector**的方法均是同步的，线程安全，但性能比ArrayList差
2. 选择
    1. 需要性能高选择ArrayList，需要线程安全选择Vecot
    2. 需要随机访问，选择ArrayList，需要插入删除友好，选择LinkedList
    - **list的遍历方式选择？**
      
        ArrayList 实现了 RandomAccess 接⼝， ⽽ LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ ArrayList 底层是数组，⽽ LinkedList 底层是链表。数组天然⽀持随机访问，时间复杂度为 O（1），所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O（n），所以不⽀持快速随机访问。， ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接⼝只是标识，并不是说 ArrayList 实现 RandomAccess 接⼝才具有快速随机访问功能的！
        
        实现了 RandomAccess 接⼝的list，优先选择普通 for 循环 ，其次 foreach,
        
        未实现 RandomAccess 接⼝的list，优先选择iterator遍历（foreach遍历底层也是通过iterator实现的,），⼤size的数据，千万不要使⽤普通for循环
        
    



## HashMap和Hashtable的区别？

1. 底层数据结构 → 扩容 → 空值、线程安全和效率（补充） 
    1. 主要区别，Hashtable（基本被淘汰，不再代码中使用）是线程安全的，里面的方法都增加了synchronized关键字来确保线程同步，HashMap线程不安全，所以性能好一点。
        1. 可以采用ConcurrentHashMap，线程安全
    2. HashMap可以用一个null存放key，多个null存放value，Hashtable不可以存放null键和null值
    - 扩容
    - 总结
      
        hashtable是基于hashmap实现的，hashtable线程安全是因为每个方法都添加了synchronized关键字，所以hashmap性能更好，而且hashmap可以存空键，空值，但hashtable不行
        



## HashMap和HashSet的区别？

1. HashSet底层基于HashMap实现，除了clone()、 writeObject()、readObject()自己实现，其余均是调用HashMap
2. 接口 → 存储的元素 → 插入删除 → hashcode
    1. HashMap，Map接口，HashSet，Set接口→ List接口
    2. HashMap，存储键值对，线程不安全，HashSet，仅存储对象，元素唯一、可以是null，线程不安全
    3. HashMap，使用键计算HashCode，HashSet，利用成员对象计算hashcode值，因为hashcode值可能相等，所以用equals判断对象是否相等
        1. HashMap比HashSet快，因为使用唯一键获取对象
- 总结
  
    HashSet底层基于HashMap实现，除了clone()、 writeObject()、readObject()自己实现，其余均是调用HashMap。hashmap存储键值对，hashset存储对象，hashmap比hashset快，因为使用唯一键获取对象，hashmap的hashcode的计算方式是键，hashset是成员对象
    



## HashSet如何检查重复?

- 或者称之为HashSet如何添加元素？
  
    元素在添加时，会首先计算元素的hashcode值判断添加的位置，然后判断容器中是否存在相同的hashcode值，如果不存在，添加，如果存在，继续用equals方法比较这两个hashcode值相同的元素是否相同，相同，则不添加，不相同，则修改hashcode值再添加
    
    1. 两个方法都是判断对象是否相同，只是hashCode可以提高效率，但是只有hashCode并不代表两个对象一定相同，因为存在哈希碰撞，不同的对象可能有相同的哈希值。



## 为什么要有HashCode()？

hashCode()是为了获取哈希码，可以得到对象在散列表中的位置。hashCode()和equals()一样定义来JDK里面的Object类中，意味着Java中任何类都含有hashCode()函数。

### 为什么要重写equals是要重写hashcode

1. 如果重写equals不重写hashcode的话，可能导致equals判断两个对象是相等的，但是hashcode值是不相等的，这样的对象在添加到map、set容器的时候，会导致map的键值不是一对一，而是多对一，set存放多个相同的对象。
    1. 再深入就解释set容器添加元素的机制
    2. hashCode相同，对象不一定相等
    hashCode相同并且equals为true，则对象相等
    hashCode不同，则对象不相等



## 如何选用集合？

为了避免HasMap的线程安全问题，改用HashTable 或者 Collections.synchronizedMap() 方法

但是它们会加锁，导致性能变差

所以采用ConcurrentHashMap，优势在于兼顾性能和线程安全，一个线程进行写操作时，它会锁住一小部分，其他部分的读写不受影响，其他线程访问没上锁的地方不会被阻塞

# ConcurrentHashMap

`java.util.concurrent.ConcurrentHashMap`属于 JUC 包下的一个集合类，可以实现线程安全

[深入浅出ConcurrentHashMap详解_学哥斌的博客-CSDN博客_concurrenthashmap](https://blog.csdn.net/qq_29051413/article/details/107869427)

[ConcurrentHashMap实现原理及源码分析](https://www.cnblogs.com/chengxiao/p/6842045.html)


