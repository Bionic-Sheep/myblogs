# 面向对象

## 成员变量、局部变量的区别？

声明 --> 生命周期 --> 内存空间 --> 默认初始化 -->修饰符

### 成员变量

1. 成员变量**声明在类中**，在整个类中均可访问
2. 随着**对象的生命周期而存在**，存在对象所在**堆内存**中
3. **默认初始化**，可以用**修饰符修饰**
4. 成员变量根据**static修饰符**可分为实例变量或类变量

### 局部变量

1. 声明在**局部范围**，如方法内、语句内。

2. 存于**方法区**，**栈内存**中。随着**调用的方法执行完毕**，变量空间自然释放

3. **没有默认初始化**，定义后需要初始化，**不可用修饰符修饰**，权限跟随方法、构造器的权限

   

## 成员(实例)变量和静态变量的区别：

生命周期 → 调用方式 → 别名 → 内存空间

无 static 和 有 static 

1、两个变量的生命周期不同

成员变量随着**对象**的创建而存在，随着对象的回收而释放。

静态变量随着**类的加载**而存在，随着类的消失而消失。

2、调用方式不同

成员变量只能被**对象调用**。

静态变量可以**被对象调用**，还可以**被类名调用**。

3、别名不同

成员变量也称为**实例变量**。

静态变量也称为**类变量**。

4、数据存储位置不同

成员变量存储在**堆内存的对象中**，所以也叫对象的特有数据。

静态变量数据存储在**方法区（共享数据区）的静态区**，所以也叫对象的**共享数据**。



## 方法的重写和重载的区别？

### 重载：

**相同的方法名**根据不同的输入数据，做出不同的处理。

发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

其中可变长参数 `Object...args`

在方法调用时传入不定长度的参数，只能作为参数列表最后一个，重载时优先加载固定参数函数，因为匹配度更高。可变参数在编译后会被转换成一个数组。

### 重写：

当子类继承父类相等的方法，为了做出与父类不同的响应，**重写该方法的实现**。

1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 **private/final/static** 则子类就不能重写该方法，但是被 static修饰的方法能够被再次声明
3. 构造方法不能重写

关于 **重写的返回值类型** 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 **void 和基本数据类型**，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。



## 静态方法和非静态方法的调用？

1. 调用方式不同，静态方法可以`类.方法名`和`对象.方法名`调用，而实例方法只能用`对象.方法名`，**调用静态方法不需要创建对象。**静态方法不属于对象，属于这个类。
2. 访问类成员限制，静态方法访问本类成员，只能访问静态对象，不能调用非静态成员。
3. 静态方法是属于类的，在类加载会分配内存，可以通过类名直接访问，但非静态成员只有在对象实例化后才会存在，并通过类的实例化对象访问。
4. 在类的非静态成员存在时，静态方法已经存在，调用不存在的东西属于属于非法操作。



## 值传递

值传递：在调用函数时将实际参数复制一份传递到函数中，在函数中对参数进行修改，不会影响到实际的参数

引用传递：在调用函数时，将参数的引用地址传递到函数中，那么再函数中对参数进行的修改，直接影响到实际参数

![](https://cdn.jsdelivr.net/gh/Bionic-Sheep/typora/images/2021041914383477.jpg)

Java中只存在值传递，会将对象的地址拷贝传递给被调函数的形式参数。传递的内容是对象的引用

## 面向对象三个特性



### 封装性

封装性体现在下面两个地方

1. 给属性或方法用private修饰符私有化，同时提供公共的set和get方法
2. Java的四个权限修饰符

**优点：**

1. 减少耦合

**单例模式**

类里面只有一个实例对象。

优点：只有一个实例、减少了内存的开销、特别是频繁的创建和销毁实例、避免了对资源的多重占用。

缺点：没有接口、不能继承

使用场景：

1.  生产唯一的序列号
2.  计数器，不用每次刷新在数据库加一次，用单例模式缓存

饿汉模式

```java
//饿汉式1
class Bank{
     
	//1.私化构造器，阻止外界实例对象
	private Bank(){}
	
	//2.内部提供一个当前类的实例
	//4.此实例也必须静态化
	private static Bank bank = new Bank();
	
	//3.提供公共的静态的方法，返回当前类的对象，获取该对象
	public static Bank getInstance(){
		return bank;
	}
}
```

懒汉模式

```java
class Bank1{
	
	//1.私化构造器，阻止外界实例对象
	private Bank1(){}
	
	//2.声明当前类的实例
	//4.此实例也必须静态化，先不创建对象
	private static Bank1 bank = null;
	
	//3.提供公共的方法获取当前类的实例
	public static Bank1 getInstance(){
		if(bank == null){ //需要当前方法则创建对象
			bank = new Bank1();
		}
		return bank;
	}
	
}
```

两种方式的区别

饿汉：对象加载时间过长，线程安全

懒汉：延迟对象加载，线程不安全

要想实现线程安全的懒汉式单例模式

双重检查加锁机制

加锁是耗费资源的事，在加锁前，先判断实例是否存在，如果不存在，则加锁，并且在创建实例前再次判断，这是因为在加锁前就需要再次检查

增加volatile 关键字在实例变量，因为需要在bank变量在发生变化后需要及时将结果刷新到主内存，对其他线程可见

```java
public class Bank_ {
    // 私有化构造器
    private Bank_(){}

    // 增加volatile 关键字，因为需要在bank变量在发生变化后需要及时将结果刷新到主内存，对其他线程可见
    private static volatile Bank_ bank = null;

    public static Bank_ getBank(){
        if(bank == null) { //因为加锁耗费资源，在加锁前先检查是否为空，如果为空，加锁，创建实例，再判断是否为空
            synchronized (Bank_.class) { //加锁
                if (bank == null) {
                    bank = new Bank_(); // 懒汉式
                }
            }
        }
        return bank;
    }
}
```





有关单例模式更详细的内容见下：

[菜鸟教程](https://m.runoob.com/design-pattern/singleton-pattern.html)

**权限修饰符**

![https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220417140057.png](https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220417140057.png)



### 继承性

一个类可以拥有另一个类的属性和方法。

特点：

1. 所有的类都直接或间接继承java.lang.Object，继承是对父类的扩展
2. 具有**单继承性，**一个人只有一个爹，一个爹可以有很多儿子。

优点：

1. 减少代码冗余、提高复用性
2. 拥有扩展性，是多态的前提

规则：

1. 子类A继承父类B以后，就获取了父类中声明的结构：属性、方法（不管权限如何）
2. 子类可以在继承父类的基础之上，再提供自己特有的属性或方法。
3. 子类不能直接访问父类中私有的(private)的成员变量和方法，也不能重写和重载，只能重新写一个



### 多态性

多态就是一个类的多种形态，例如体现在

1. 方法的重写和重载
2. 子类对象的多态性：父类的引用指向子类的对象 `Person p1 = new Man();`

多态的应用：虚拟方法调用：编译时，认为调用的方法是父类的，但是当**运行时，实际执行的是子类重写父类的方法**；注意：多态中方法的调用：编译看左边，运行看右边；

前提是：拥有继承关系和方法重写



## 抽象类和抽象方法

**格式**：`class abstract 类名` 和`权限修饰符 abstract 返回值类型 方法名（形参）`

**前提**：类的继承性

1. 类具有构造器 ，抽象类不可实例化，一般是抽象类的子类实例化来调用父类的结构
2. 有常量和普通变量
3. 具有抽象方法和普通方法
4. 抽象类不一定有抽象方法，抽象方法所属类一定是抽象类
5. 抽象方法不能被调用，没有方法体，**只能被重写**。继承抽象类的子类**必须重写父类所有的抽象方法，**否则，该子类也必须声明为抽象类。



## 接口

**格式：**`interface 接口名` 

1. 没有构造器，不能直接使用，需要类实现接口
2. 只有常量
3. 只有抽象方法，在JDK8后有默认方法和静态方法
4. 接口实现类必须覆盖接口中**的所有方法**（JDK8新增了静态方法、**默认方法**），因为如果类实现了多个接口（解**决单继承性**问题），可能会出现接口冲突问题
5. 类实现了接口，就可以获取接口中声明的结构：**常量、抽象方法**



## 抽象类和接口的区别？

**共同点**：

1. 均包含抽象方法，继承多个接口，实现或继承它们的普通类必须重写抽象方法
2. 都不能实例化，都需要被继承和实现

**不同点**：

1. **用途不同**：接口可以对类的行为进行约束，实现了某个接口就有对应的方法，抽象类，主要用于代码复用，强调所属关系，例如抽象类表示这个对象是什么，有什么属性，强调类的共性，接口表示这个对象要干什么，强调对象的操作

2. **继承性**：抽象类具有单继承的局限性，只能继承一个，但是可以实现多个接口

   1. 类和类：单继承和多层继承，类和接口，单实现和多实现，在继承一个类的同时还可以实现接口，接口和接口，单实现和多实现

3. **成员不同**：**抽象类**有构造器，成员变量可以是变量或者常量，成员方法也是可以方法或者抽象方法，**接口**没有构造器，只能是常量，方法只能是抽象方法，**jdk8**后可以有静态方法和默认方法

   ![https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220418143321.png](https://cdn.jsdelivr.net/gh/Bionic-Sheep/typora/images/20220418143321.png)



## 抽象类和接口选择的区别与依据？

[接口和抽象类的区别(绝对经典)](https://blog.csdn.net/qq_42848910/article/details/107962882?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&utm_relevant_index=1)

接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。

抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。

人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.

所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。

当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度。



## 静态~static

静态对象和静态方法：被 `static` 修饰：存放在方法区（永久代）中，被类的所有对象共享，即被所有线程共享。

静态方法可以调用静态变量和静态属性，但不能调用非静态属性和方法，因为静态变量和方法是随着类加载而加载，但是实例变量是随着对象创建而存在，静态变量存在时，实例变量可能还不存在，属于非法操作。反之亦可。



## Object类

1. Object是所有类的父类
2. 只定义了一个Object（）

### equals()

1. `public boolean equals(Object obj) {return (this == obj);}` 在Object的定义方式。
   1. 比较两个对象的地址值是否相等，所以在自定义类时，需要重写euqlas方法，不然在比较引用类型时，比较的时两个对象的地址时，但是在比较基础类型时，比较的是数值。

### toString()

1. `public String toString() {return getClass().getName() + "@" + Integer.toHexString(hashCode());}`在Object的定义方式。



## == 和 equals（）的区别

在Java中，有两种数据类型，一种是基本数据类型，一种是引用类型。

==在比较基本数据类型时，直接比较它们的值，在比较引用类型时，比较的是它们的内存地址，比较它们是否为同一个对象

equals是Object类的方法，在没有重写前，效果和==是一样的，一般为了比较两个类的对象的某个内容相同，会重写equals。



## throws 和 throw的区别

throws                                 throw
① 自动抛出异常；                 ① 手动抛出异常
② 此异常抛给父类，              ② 在方法中抛出异常；
并没有进行解决；                  ③ 可以抛出自定义的异常信息；
③ 在最后的父类（main）
方法中运用 try-catch-finally
来解决异常；
④ 在方法的声明中抛出异常
给父类；