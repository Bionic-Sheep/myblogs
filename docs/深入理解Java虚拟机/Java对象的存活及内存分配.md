# Java对象的存活及内存分配

# 确定对象是否死亡

引用计数法和可达性分析算法

## 引用计数法：

在对象中添加一个引用计数器，引用一次，计数加1，引用失效，计数减1，当计数为0，该对象不可用

特点；占用额外内存，但原理简单，判定效率高

## 可达性分析算法：

将根对象（GC Roots）作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索路径为‘引用链’，如果某对象到GC Roots间没有任何引用链，即不可达，则该对象不可能再次被使用

# 引用类型？

 判断对象是否存活都和“引用”离不开关系。

JDK1.2之前：reference类型的数据中存储的是代表另一块内存的起始地址，就表示reference数据代表某块内存、某个对象的引用。

JDK1.2之后：扩展引用概念，强引用、软引用、弱引用和虚引用。

**强引用**：一般指程序代码之间的引用赋值，无论任何情况，只要强引用关系存在，垃圾收集器永远不回收掉该引用的对象。

**软引用**：还有用，并非必须的对象。在系统发生内存溢出前，会回收软引用的对象（第二次回收过程），如果回收后还没有足够内存，发生内存溢出异常。JDK1.2之后提供SoftReference类实现软引用。

**弱引用**：非必须对象。该对象只能生存到下一次垃圾收集发生为止，当垃圾收集器开始工作，必定回收弱引用关联的对象。JDK1.2之后提供WeakReference类实现。

**虚引用**：一个对象是否有虚引用的存在，完全不对生存时间产生影响，也无法通过虚引用取得对象实例。唯一目的是**该对象回收时会有一个系统通知**。JDK1.2之后提供PhantomReference类来实现。

# 对象的真正死亡

一个对象死亡需要标记两次

第一次：对该对象进行可达性分析，如果没有和GCRoots相链接，再继续第二次判断

第二次：判断该对象是否有必要执行finalize()方法，不执行就死亡

# 废弃常量和废弃类

方法区的垃圾回收两种：**废弃常量和不再使用的类型**。

什么样的情况下回收常量：**系统中没有字符串常量值是该常量，虚拟机中无地方引用该字面值。**

例如，一个字符串常量"Java"曾经进入常量池中，但是当前系统没有任何一个字符串对象值是"Java"常量，虚拟机也没有其他地方引用该字面值。此时发生内存回收，垃圾收集器判断确有必要的话，"Java"常量就将被系统清理出常量池。

1. 所有实例被回收，Java堆中不存在类和派生子类的实例
2. 加载类的类加载器被回收。
3. 类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

# 内存分配和响应策略

对象内存分配，都是在堆上分配。

Java堆是垃圾收集器的主要区域，因此被称为GC堆，从垃圾回收角度，由于现在收集器都是采用分代垃圾收集算法

所以Java堆细分为**新生代**和**老年代**。再细致一点：Eden空间，FromSurvivor, To Sruvivor。

![未命名图片1.png](Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E6%B4%BB%E5%8F%8A%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%204b0fc54868174153b06b7caf813afed6/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D%25E5%259B%25BE%25E7%2589%25871.png)

## 对象优先在Eden分配

对象在新生代Eden区中分配时，如果Eden区没有足够空间进行分配时，虚拟机发起一次minor gc。

## 大对象直接进入老年代

大对象就是需要大量连续内存空间的Java对象（字符串、数组）。

在分配空间时，容易导致内存还有不少空间就触发垃圾收集，来获取足够的连续空间来存放大对象。

在复制时，意味着高额的内存复制开销。

HotSpot虚拟机提供了参数，指定大于该参数的对象直接进入新生代。避免在新生代之间来回复制，产生内存开销

## 长期存活的对象直接进入老年代

每个对象都定义了一个年龄计数器，存放在对象头中。当经历过第一次Minor GC还能被Survivor接纳，年龄设置为1，每经历一次Minor GC，年龄就增加1岁。当增加到一定年限时，就晋升到老年代。对象晋升到老年代的年龄阈值，可以通过参数 **-XX:MaxTenuringThreshold** 来设置

## 动态对象年龄判定。

如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。

## 空间分配担保

在发生Minor GC前，虚拟机首先检查老年代最大可用的连续空间是否大于新生代所有对象空间。yes，则Minor GC是安全的。如果no，检查 -XX:HandlePromotionFailure 参数的设置值是否允许担保失败，yes，则检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。如果大于，进行一次Minor GC尝试。如果不是，进行Full
GC。