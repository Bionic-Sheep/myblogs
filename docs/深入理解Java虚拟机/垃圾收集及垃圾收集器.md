# 垃圾收集及垃圾收集器

# 垃圾回收算法

**引用计数式垃圾收集** 和 **追踪式垃圾收集**

## 分代收集理论

弱分代：大对数对象都是朝生夕灭的。

强分代：熬过多次垃圾收集过程的对象就越难以消亡。

**设计原则**：收集器应该将Java堆划分为不同的区域，然后将回收对象依据年龄(熬过垃圾收集的次数）分配到不同的区域。

优点：如果一个区域都是朝生夕灭的对象，将它们集中在一起，只关注少量存活的对象不标记那些被回收的对象，低代价回收大量空间，剩下的都是难以消灭的对象，集中在一块，以较低频率来回收。

将Java堆中划分两个区域：新生代和老年代。每次垃圾收集，新生代中大量的对象死去，每次存活的对象将逐步存放到老年代区域中。

# 垃圾收集算法

三种算法：清除-复制-整理

## 标记-清除

定义：标记所有需要回收的对象，在标记完成后，回收掉所有标记的对象

缺点：1. **执行效率不稳定**，如果Java堆中存在大量对象，那么需要标记和清除的对象也很多，标记-清除过程中的执行效率随对象数量增长而降低。

1. **内存空间碎片化**，标记-清除会产生大量不连续的碎片
   
    ![image-20220918144435168](https://cdn.jsdelivr.net/gh/Bionic-Sheep/typora/images/image-20220918144435168.png)
    

## 标记-复制

定义：将可用容量划分为大小相等的两块，每次只使用其中一块A，当这一块内存A使用完，将还存活的对象复制到另一块内存B上，然后将使用过的内存A全部清理。

优点：分配内存不再考虑空间碎片，只需要移动堆顶指针，按顺序分配。

缺点：内存容量减少一半

![image-20220918144406612](https://cdn.jsdelivr.net/gh/Bionic-Sheep/typora/images/image-20220918144406612.png)

分配内存时，不一定按照1:1的策略分配，将新生代分为一块较大的Eden空间和两块较小的Surivor空间（8:1:1）

在垃圾收集时，将Eden和Surivor存活的对象复制到Surivor空间，然后清理掉Eden和Surivor

## 标记-整理

标记整理算法和标记清除算法非常像，不同点在于标记之后，清除算法是直接对对象进行回收，整理算法是让所有存活的对象向内存空间一端移动，然后直接清理掉边界以外的内存区域。

# 经典垃圾收集器

没有万能的垃圾收集器，选择具体应用合适的收集器。

## Serial收集器

基础、单线程。进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

新生代采用**标记-复制**算法，老年代采用**标记-整理**算法。

默认的新生代收集器，简单高效。内存资源受限的环境，所有收集器额外内存消耗最小。

适用于运行在客户端模式下的虚拟机。

## ParNew收集器

是Serial收集器的多线程并行版本，除了多线程收集，其余行为均与Serial收集器一致。

新生代采用**标记-复制**算法，老年代采用**标记-整理**算法

运行在服务端模式下的虚拟机。除了Serial收集器外，目前只有它能和CMS收集器配合工作。

## Parallel Scavenge收集器

新生代收集器，同样基于**标记-复制**算法实现的收集器，能够并行收集的对线程收集器。不同与CMS收集器尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge收集器达到一个可控制的吞吐量。

吞吐量 = （运行代码时间）/ (运行代码时间 + 运行垃圾收集时间）

高吞吐量可以最高效率地利用处理器资源，尽快完成程序的运行任务，主要适用于后台运算而不需要太多交互的分析任务。

提供两个参数用于精准控制吞吐量：最大垃圾收集停顿时间 和 直接设置吞吐量大小。垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。

## Serial Old收集器

老年代版本，单线程收集器，使用标记-整理算法。两种用途：1. JDK5及之前，与Parallel Scavenge收集器搭配使用，另一种作为CMS收集器发生失败时的后备预案。

## Parallel Old

老年代版本，多线程并发收集，基于标记-整理算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器

## CMS收集器

一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法。

步骤：

1.初始标记：标记GC Roots能直接关联到的对象。

2.并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程。

3.重新标记：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。

4.并发清除：清理删除标记阶段判断已经死亡的对象。

缺点：1.对处理器资源敏感。

2.无法处理浮动垃圾（在并发标记和并发清理阶段，用户还是在不断产生垃圾，出现在标记过程结束后

1. 基于标记-清理算法，会产生内存空间碎片。

## G1收集器

面向服务器的垃圾收集器，针对多核处理器和大内存情况，缩短停顿时间的同时还具有高吞吐量。 面向**堆内存任何部分**来组成回收集，衡量标准不是那个分代，而是那个内存块的垃圾最多，回收效益最高。

**初始标记**：标记GC Roots能直接关联到的对象，需停顿线程。

**并发标记**：从GC Roots开始对堆中对象进行可达性分析，找出回收对象，并发执行。

**最终标记**：对用户线程做一个短暂的暂停，处理并发阶段产生的记录。

**筛选回收**：对Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划。

## G1收集器和CMS收集器的区别

同：都非常关注停顿时间的控制。

异：

1. G1可以指定最大停顿时间，分Region的内存布局，按收益动态确定回收。 2. G1整体是基于“标记-整理”的收集器，局部上看又是基于“标记-复制”，所以G1运行期间不会产生内存空间碎片。而CMS是基于“标记-清除”的收集器。（优点）
2. G1无论是垃圾收集产生的内存占用还是程序运行时的额外执行负载都比CMS高。4. 内存占用使用两者都使用卡表处理跨代指针，G1卡表实现更为复杂。（缺点）

# 名词

## STW：stop-the-world

JVM要执行GC而停止了应用程序的执行，当STW时，除了GC所需的线程外，所有线程处于等待状态，直到GC任务完成，GC优化很多时候就是指减少STW的时间

## 新生代

大部分新对象被分配到该内存区域，因为部分对象在创建后很快不可达，然后消失，这个过程为minor GC

## 老年代

新生代区域的对象在经历过若干次GC后，存活下来，会被拷贝至老年代，当老年代的对象消失，这个过程为major GC

## Young GC 和 Full GC

Eden区满时，触发Young GC，针对年轻代。

Full GC则是针对整个堆

## FullGC的触发场景

1. 调用System.gc()
2. 没有指定老年代和新生代的大小，堆伸缩时会产生fullGC，所以需要配置-Xmx,-Xms
3. 老年代的空间不足
4. 空间分配担保失败
   1. 每次晋升对象的平均大小>老年代剩余空间
   2. Minor GC后存活的对象超过了老年代剩余空间