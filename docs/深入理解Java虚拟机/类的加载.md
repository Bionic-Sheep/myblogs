# 类的加载

![https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220409155503.png](https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220409155503.png)

Class文件需要加载到虚拟机中才能运行和使用，那么虚拟机是如何加载这些class文件呢？

系统加载Class类型文件主要三步：加载->连接->初始化。连接过程又分为三步：验证->准备->解析

加载-验证-准备-解析-初始化

# 加载

读取**Class文件，**将其转换为某种**静态数据结构**存储在**方法区**内，并在**堆**中生成一个便于用户调用的**java.lang.Class类型的对象**的过程。

1. 通过**全类名**获取此类的**二进制字节流**
2. 将字节流所代表的的**静态存储结构**转换为方法区的**运行时数据结构**。
3. 在内存中生成一个代表该类的class对象，作为方法区这些数据的访问入口。

一个非数组类的加载阶段（获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以完成还可以**自定义类加载器**去控制字节流的获取方式（重写一个loadClass()方法）。数组类型不通过类加载器创建，由Java虚拟机直接创建。

# 验证

![https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220409155752.png](https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220409155752.png)

# 准备

为静态变量赋零值，HotSpot在JDK8后将常量池和静态变量移除了方法区，元信息依然存储在方法区中，只是存储的方式以前是永久代，现在是元空间

为类变量分配内存并设置类变量初始值的阶段

1. 内存分配：类变量，即静态变量，被static修饰的变量。Java堆：实例变量随着对象实例化与对象一起分配到堆中
2. 类变量使用的内存都在方法区中进行分配，在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。
3. 初始值：一般为数据类型默认的零值。例如我们定义了public static int value=111 ， value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。

![https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220409160026.png](https://raw.githubusercontent.com/Bionic-Sheep/typora/main/imgs/20220409160026.png)

# 解析

解析阶段是虚拟机将**常量池内**的**符号引用**替换为**直接引用**的过程。

解析动作主要针对**类或接口**、**字段**、**类方法**、**接口方法**、**方法类型**、**方法句柄**和**调用限定符** 7 类符号引用进行。

**符号引用：**就是一组符号来描述目标，可以是任何字面量。

**直接引用：**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### 静态解析和动态解析

假设加载类A，类A中引用类B，类A加载编译后，是不知道类B有没有加载，此时用一个字符串S表示类B的符号引用，只有当类A开始运行后，开始加载类A，当在解析阶段会发现类B并没有被加载，此时触发B的类加载，添加到虚拟机中国，此时将符号引用替换成直接引用，A就直接调用B了。当然因为java存在多态、后期绑定等特征，类B可能就是一个具体类，则是**静态解析**，假如B是抽象类或者接口，那么类B的实现并不明确，就不知道将符号引用替换成那个直接引用，所以解析有时候会发生在初始化后，这就是**动态解析**。

在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

综上，解析阶段是虚拟机将**常量池内的符号引用替换为直接引**用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

# 初始化

判断代码中是否存在主动初始化动作，是否赋值，静态代码块等

初始化阶段是执行初始化方法<clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

对于<clinit> () 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <clinit> ()方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。

对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：

1. 当遇到 new 、 getstatic、putstatic 或 invokestatic 这 4 条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
    - 当 jvm 执行 new 指令时会初始化类。即当程序创建一个类的实例对象。
    - 当 jvm 执行 getstatic 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。
    - 当 jvm 执行 putstatic 指令时会初始化类。即程序给类的静态变量赋值。
    - 当 jvm 执行 invokestatic 指令时会初始化类。即程序调用类的静态方法。
2. 使用 java.lang.reflect 包的方法对类进行反射调用时如 Class.forname("..."), newInstance() 等等。如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。
5. MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类。
6. 当一个接口中定义了 JDK8 新加入的默认方法（被 default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

# 卸载

卸载类即该类的 Class 对象被 GC。

卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被 GC

所以，在 JVM 生命周期内，由 jvm自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，jdk 自带的BootstrapClassLoader, ExtClassLoader, AppClassLoader 负责加载 jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。