# Java内存区域与内存溢出异常



## 运行时数据区

![Untitled](https://cdn.jsdelivr.net/gh/Bionic-Sheep/typora/images/20220412105138.png)

## 什么是Java字节码？

Java源代码经过编译器编译后产生的文件，只面向虚拟机。这也是Java跨平台性的原因，一次编译到处运行。在虚拟机上执行。

**优点**：字节码不针对特定机器，只面向虚拟机执行，因此不用重新编译就可以在不同的计算机上运行。

```java
Java源码-->编译-->字节码.class文件，即JVM可执行的Java字节码-->JVM-->JVM解释器-->二进制码-->程序运行
```



## Java的内存区域

### 程序计数器

1. 当前线程所执行字节码的行号指示器，程序的基础功：分支、循环、跳转都依赖它
2. 为什么需要程序计数器？
   
    因为Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式实现的，一个处理器执行一条线程指令，为了在线程切换后恢复到正确的执行位置，每个线程需要一个独立的程序计数器
    
3. 线程执行Java方法：记录虚拟器字节码指令地址，本地方法：值为空

### 虚拟机栈|本地方法栈

创建一个线程就会创建一个虚拟机栈，每个方法被执行或调用时，就会创建一个栈帧放入虚拟机栈中，存储**局部变量表、操作数栈、动态链接、方法出口**等信息。每个方法被调用完，就对应了一个栈帧入栈到出栈的过程。

本地方法栈执行的是本地方法，作用和虚拟机栈类似

扩展时，无法申请到新的内存区域，OOM

### 堆

线程共享的一块区域，在虚拟机启动时创建，唯一目的是**存放对象实例**。

垃圾收集在堆上进行，也被称为GC堆，物理上可以不连续，但逻辑上连续，可固定可扩展

注：具体的堆在后面会讲解

JVM无法给实例分配内存，就会产生OOM异常

### 方法区

线程共享的一块区域，存储被被虚拟机加载的信息：常量、静态变量、即时编译器、编译后的代码缓存等。

无法满足内存分配需求时，OOM



## 创建对象的五种方式？

1. 通过**new**关键字创建：Object obj = new Object()
2. 通过Class类的newInstance()方法：默认调用 类的无参构造方法来创建对象:
   
    Person p = (Person) Class.forName("com.hutao.test.Person").newInstance()
    
3. Constructor类的newInstance()方法
4. 通过clone()方法：clone是Object类的一个方法，通过 对象A.clone()方法会创建一个和A一模一样的对象B
5. 反序列化：

序列化，即把堆内存中的对象通过某种方式以二进制流的形式把它储存到磁盘文件中或传输给其他网络节点。

而反序列化则是将磁盘中文件的对象数据或网络节点的对象数据恢复成java 对象的过程。



## 对象的创建过程

以HotSpot为例

### 对象创建

遇到一个字节码new指令，先检查指令能否在**常量池**中定位到**类的符号引用**，再检查引用是否被类加载、解析、初始化。如果无，则执行类加载过程

![image-20220917140550438](https://cdn.jsdelivr.net/gh/Bionic-Sheep/typora/images/image-20220917140550438.png)

### 分配内存

将一块**确定大小的内存块**从Java堆中划分：指针碰撞和空闲列表

分配方式：Java堆是否规整决定的，是否规整由垃圾收集器决定，是否带有压缩整理功能。

1. **指针碰撞**：以指针为分界点，一边是空闲的内存区域，一边是使用过的内存区域。GC收集器：Serial、ParNew
2. **空闲列表**：虚拟机维护一个列表，记录那个区域是可用的，分配时，从列表找到一块够用的区域来划分。GC收集器：CMS基于清除算法。
3. 内存分配并发问题：
    1. CAS+失败重试
    2. TLAB:**JVM为每个线程分配了一个私有缓存区域**，称为本地线程分配缓存

### 初始化

分配完毕，将分配到的内存区域初始化为零值（不包括对象头），保证**对象的实例字段在Java代码中不需要赋值就能够使用**

### 设置对象头

设置对象是那个类的实例、如何找到类的元数据信息，对象的哈希码、对象的GC分代年龄。

### init()方法→ 构造函数

经历上面四步，虚拟机认为对象已经创建完毕，接下来是按照Java程序的意图，执行构造函数，完成初始化。



## 对象的内存布局与访问定位

### 内存布局：

对象头、实例数据、对齐填充

**对象头**

1. **存储自身运行时数据**：哈希码，GC分代年龄，锁状态标志、线程持有锁、偏向线程ID、偏向时间戳
2. 类型指针，可以通过该**指针知道该对象是哪个类的实例**。

**实例数据**

存储对象真正有效的数据，在程序代码中定义的各种类型的字段内容。

**对齐填充**

占位符作用，实例数据没有补充完成，需对齐



### 访问定位

通过栈上的reference数据来操作堆上的数据

**对象实例数据**（堆）:对象中各个实例字段的数据

**对象类型数据**（方法区）：对象的类型、父类、实现的接口、方法等

**句柄访问**

Java堆中有一块内存作为句柄池，reference(引用)存放的就是对象的句柄地址，包含了对象**实例数据**和**类型数据**各自的地址信息。

**优点**：稳定的句柄地址，移除对象值会改变句柄中的实例数据，不改变reference

**缺点**：两次指针移动

![对象的访问定位-使用句柄.53859387.png](https://cdn.jsdelivr.net/gh/Bionic-Sheep/typora/images/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.53859387.png)

**直接指针访问**

Java堆中对象的内存布局必须考虑如何放置访问类型数据的相关信息，reference中**存储的直接就是对象的地址**。

好处：访问速度快，节省指针开销

![对象的访问定位-直接指针.c3bbe790.png](https://cdn.jsdelivr.net/gh/Bionic-Sheep/typora/images/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.c3bbe790.png)